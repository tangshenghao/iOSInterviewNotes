## HTTP

### 1 Web的显示

根据Web浏览器地址栏指定URL，Web 浏览器从Web服务器端获取文件资源等信息，从而显示出Web页面。

Web的通信方式是建立在HTTP协议上进行的。

<br />

#### 1.1 网络基础TCP/IP

通常使用的网络是在TCP/IP协议族的基础上运作。而HTTP属于它内部的一个子集，与互联网相关联的协议集合起来总称为TCP/IP。

<br />

#### 1.2 TCP/IP协议的分层管理

TCP/IP协议族按层次分为如下4层：应用层、传输层、网络层和数据链路层。

各层作用如下：

应用层：决定了向用户提供应用服务时通信的应用服务。比如FTP和DNS以及HTTP都是归于该层。

传输层：传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输，在该层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）

网络层：用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。

链路层：用来处理连接网络的硬件部分。包括操作系统、硬件的设备驱动、NIC（网卡）以及光纤的可见部分，硬件上的范畴均在链路层的作用范围内。

如图：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HTTP/TCP:IP%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg?raw=true)

发送端在层与层之间传输数据时，每经过一层时必定会打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层会把对应的首部消去。

如图：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HTTP/HTTP%E5%88%86%E5%B1%82%E4%BC%A0%E8%BE%93.jpg?raw=true)

#### 1.3 负责传输的IP协议

IP地址：指明了节点被分配的地址。MAC地址是指网卡所属的固定地址，IP地址可以和MAC地址进行配对。IP地址可以变换，但MAC地址基本上不会更改。

ARP协议：在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议，这是一种解析地址的协议，可以根据IP地址反复查出相应的MAC地址。

<br />

#### 1.4 负责域名解析的DNS服务

DNS协议和HTTP协议一样位于应用层，提供域名到IP地址之间的解析服务。计算机可以被赋予IP地址，也可以被赋予主机名和域名，计算机不擅长处理名称，而是擅长处理数字，所以DNS用于此。DNS协议提供查找IP地址，或反查域名的服务。

<br />

#### 1.5 URI

URI（统一资源标识符）：使用字符串标识某一互联网资源。

URL（统一资源定位符）：使用Web浏览器等访问Web页面时需要输入的网页地址。表示资源的地点，URL是URI的子集。

相对URL，是指从浏览器中基本URI处指定的URL

绝对的URI格式如：http://user:pass@www.xxxxx.com:80/dir/index.thm?uid=1#ch1

<br />

### 2 HTTP协议

HTTP协议用于客户端和服务器的通信，HTTP协议规定，请求从客户端发出，最后服务端响应该请求并返回。

POST表示请求访问服务器的类型，称为方法。随后的字符串指明了请求访问的资源对象，也叫做请求URI，最后是HTTP版本号。

请求报文的构成：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HTTP/POST%E6%96%B9%E6%B3%95%E8%AF%B7%E6%B1%82.jpg?raw=true)

响应报文的构成：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HTTP/POST%E6%96%B9%E6%B3%95%E5%93%8D%E5%BA%94.jpg?raw=true)

<br />

#### 2.1 告知服务器的HTTP方法

**GET**：获取资源

**POST**：传输实体主体

**PUT**：传输文件，存在安全性问题，一般网站不使用该方法，当配合Web应用程序的验证机制，或遵守REST标准时有可能会开放使用。

**HEAD**：获得报文头部，和GET一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期和时间。

**DELETE**：用于删除文件，和PUT相反。和PUT方法一样不带验证机制。

**OPTIONS**：询问支持的方法，用来查询针对请求URI指定的资源支持方法。

**TRACE**：追踪路径，让Web服务器端将之前的请求通信环回给客户端的方法，不常用。

**CONNECT**：要求用隧道协议连接代理。要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL和TLS协议把通信内容加密后经过网络隧道传输。

<br />

#### 2.2 Cookie

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发过去。服务端发现报文中带Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器的记录，得到之前的状态信息。

<br />

#### 2.3 GET和POST的区别

GET把参数包含在URL中，POST通过request body传递参数。

GET请求在URL中传送的参数是有长度限制的，这些长度是特定浏览器及服务器对其的限制。而POST理论上是没有限制的，一般是服务器根据处理能力进行限制。

GET可以被缓存被存到书签或浏览历史中，POST的完整参数不进行缓存。

实际上两者都不安全，因为都是明文传输。

底层也都是TCP链接。实际上两者的区别都是浏览器和服务器对其的不同限制和规定。

GET请求，浏览器会产生一个TCP数据包，POST会产生两个。

GET把请求发送过去，服务器响应200返回数据。POST是先发送Header，服务器响应100，然后浏览器再发送data，服务器响应200返回数据。但有些浏览器并不是都发送两次包，Firefox就只发送一次。

<br />

### 3 返回的HTTP状态码

返回的HTTP状态码分成5类，如下：

|      | 类别         | 原因短语                   |
| ---- | ------------ | -------------------------- |
| 1XX  | 信息性状态码 | 接收的请求正在处理         |
| 2XX  | 成功状态码   | 请求正常处理完毕           |
| 3XX  | 重定向状态码 | 需要进行附加操作以完成请求 |
| 4XX  | 客户端错误   | 服务器无法处理请求         |
| 5XX  | 服务端错误   | 服务器处理请求出错         |

<br />

#### 3.1 具有代表性的状态码

**200 OK**：表示从客户端发来的请求在服务端正常处理。

**204 No Content**：表示服务端已成功处理，但响应报文中不含实体的主体部分，如果返回204，浏览器显示的页面不会更新。

**206 Partial Content**：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

**301 Moved Permanently**：永久性保存，表示该资源已被分配了新的URL，以后应使用资源现在所指的URI。

**302 Found**：临时重定向，表示请求的资源被分配了新的URI，希望用户本次使用新的URI访问。

**303 See Other**：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。与302区别是明确了GET方法。 

**304 Not Modified**：表示请求时，服务端允许请求访问，但因发送请求未满足条件的情况后，返回。此返回不包含任何响应的主体部分。

**307 Temporary Redirect**：临时重定向，与302类似，307不会从POST变成GET。

**400 Bad Request**：表示请求报文中存在语法错误。

**401 Unauthorized**：表示发送的请求需要有通过HTTP认证信息。

**403 Forbidden**：表示服务器拒绝，没有必要给出拒绝的理由，可以在实体的主体给出原因。

**404 Not Found**：表示无法找到请求的资源。

**500 Internal Server Error**：表示服务器发生了错误，也可能是Web 应用存在bug或者故障。

**503 Service Unavailable**：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求。

<br />

### 4 HTTPS

#### 4.1 HTTPS简介

HTTP直接和TCP通信，当使用SSL时，则变成先和SSL通信，再由SSL和TCP通信。所谓HTTPS，就是身披SSL协议这层外表的HTTP。

采用SSL之后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

HTTPS端口使用的是443，因为通讯会加解密，所以比HTTP更消耗CPU和内存资源。HTTPS证书一般需要向认购机构购买。

<br />

##### 4.1.1 对称加密

需要双方都使用同一份密钥，发送出去之前进行加密，收到数据之后进行解密，都使用同一份密钥。但是需要保证双方都能有密钥。广泛使用的是AES和IDEA等。

<br />

##### 4.1.2 非对称加密

非对称加密是需要两个密钥来进行加密和解密，两个密钥是公钥和私钥。非对称加密需要先获得对方的公钥，然后通过公钥进行加密发送，然后接收到后使用存在本身的私钥来解密。

<br />

##### 4.1.3 https如何使用对称机密和非对称加密

HTTPS的解决方案是：用非对称算法随机加密出一个对称密钥，然后双方用对称密钥进行通信。具体来说就是客户端生成一个随机密钥，用服务器的公钥对这个密钥进行非对称加密，服务器用私钥进行解密，然后双方就用这个对称密钥来进行数据加密。

<br />

#### 4.2 HTTPS建立连接过程

1. client向server发送请求，连接到443端口，发送消息主要是随机值1和客户端支持的加密算法。
2. server接收到消息之后给client响应握手消息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。
3. 接着server给client发送第二个响应报文是数字证书，服务端必须要有一套数字证书，一般是向机构申请。将公钥证书发给client，只包含了证书的颁发机构、过期时间、服务器的公钥、认证的签名、域名等内容。
4. 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发的机构、过期时间等等，如果发现异常，则会弹出警告框，提示证书存在问题。如果证书没问题，那么就生成一个随机值（预主私钥）。
5. 客户端认证证书通过之后，将随机值1、随机值2和预主私钥组装会话密钥，然后通过证书的公钥加密会话私钥。
6. 将上述得到的加密后的会话私钥传给服务端。
7. 服务端收到后，用服务器的私钥解密得到随机值1、随机值2和预主私钥，然后组装得到会话私钥。
8. 客户端通过会话私钥加密一条消息发送给服务端，主要验证服务端是否正常收到了客户端加密的消息。
9. 同样服务端也会通过会话私钥加密一条消息回传给客户端，如果客户端能够正常接收表示SSL层连接建立完成了。



#### 4.3 Charles抓包原理

原理就是Charles作为“中间人代理”，拿到了服务器证书公钥和HTTPS连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会报警并中止连接。

如果要防止抓包，可以将服务端的公钥证书在编译时打进项目中，收到公钥时进行校验，如果是同样的证书才进行通信。

Charles抓包原理流程如下：

1. Charles先拦截客户端的请求，伪装成客户端向服务器进行请求。
2. 服务器向客户端（实际上是Charles）返回公钥证书
3. Charles拦截服务器的响应，获取公钥，然后自己制作了一张证书，将服务器证书替换后发送给客户端。
4. 客户端收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）
5. Charles拦截客户端的响应，用自己的私钥解密得到对称密钥，然后用服务器证书公钥加密，发回给服务器。（此时Charles拿到了通讯用的对称密钥）
6. 服务器用自己的私钥解密后也拿到对称密钥，向“客户端”（Charles）发送响应
7. Charles拦截服务器的响应，替换成自己的证书后发送给客户端，客户端收到后就建立起通讯连接了。

通过上述过程，最终Charles就可以截取到双方的数据并且可以对其修改再进行传递。



### 5 HTTP1、Http2和Http3的区别

#### 5.1 Http 1.x

最主要的缺陷是线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞。

##### 5.1.1 Http1.0（短连接）

缺陷：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；

解决方案：添加头信息 -- 非标准的Connection字段Connection: keep-alive

##### 5.1.2 Http1.1

改进点：

1. 持久连接（与Http1.0版本的最大区别）引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection:keep-alive（对于同一个域名，大多数浏览器允许同时建立6个持久连接）
2. 管道机制，在同一个TCP连接里面，客户端可以同时发送多个请求。
3. 分块传输编码，即服务端每产生一块数据，就发送一块，采用“流模式”取代”缓存模式“。
4. 新增请求方式。PUT、DELETE、OPTIONS、TRACE、CONNECT。

缺点：

虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头阻塞”。

避免方式：一是减少请求数，二是同时多开持久连接。

#### 5.2 Http2.0

特点：

采用二进制格式而非文本格式；

完全多路复用，而非有序并阻塞的。只需一个连接即可实现并行；（解决了队头阻塞的问题，与Http1最重要的区别）

使用报头压缩，降低开销

服务器推送

##### 5.2.1 二进制协议

Http/1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。Http/2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”：头信息帧和数据帧。

二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

#### 5.3 Http3.0

Http2.0虽然解决了多路TCP复用和队头阻塞问题，但实际上还是基于TCP的协议上进行传输，同时在同一路TCP上复用还是会出现超时的情况，一旦中间有包未收到响应超时，则会触发重传，会对该单一通道造成阻塞，所以并没有完全解决队头阻塞的问题。

基于上述问题，就诞生了基于UDP协议的“QUIC”协议，让HTTP在该协议上与跑，而不是在TCP上。

UDP不需要握手和挥手，所以比TCP快。QUIC也实现了可靠传输，保证数据可靠性，同时还引入了类似HTTP2流和多路复用的概念。QUIC协议有以下特点：

- 实现了类似TCP的流量控制、传输可靠性的功能
- 实现了快速握手功能
- 集成了TLS加密功能
- 多路复用，彻底解决TCP中队头阻塞的问题
- 连接迁移
